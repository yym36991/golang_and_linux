
基本语法学习
# 1、new和make的区别
<details>
  <summary>查看/隐藏代码</summary>
  入参和出参不同：都是接收类型Type, new只接收一个形参，返回这个类型的指针，make接收类型Type,和其他参数，长度、容量等，返回Type类型，（传指针返回指针，传类型返回类型） <br>
  使用场景不同：专门用来构造slice,map,chan类型，等引用类型。比如slice包括一个数据结构：返回底层数组的指针， new不能用来构造引用类型，因为会做零值处理，指针做0值，会处理成nil，显然是错的。<br>
  
</details>

# 2、切片和数组的区别？slice 底层数据结构和一些特性？
<details>
  <summary> 查看/隐藏</summary>
  数组是值类型<br>
  切片会动态扩容，<br>
  slice 底层数据结构是一个结构体，包含三个字段：指向底层数组的指针、长度、容量。<br>
  slice 特性：<br>
    1. 动态扩容：切片A如果append到大于容量，会指向新数组，原数组会被垃圾回收。如果A切片有引用B，则引用的B和B指向的原来的数组不会随着扩容而变化，但是A变成了新扩容的新地址<br>
    2. 共享底层数组：当切片和原数组的底层数组指针相同，则切片和原数组共享底层数组，修改切片会影响原数组。<br>
    3. 切片长度不能超过容量：当 slice 长度超过容量时，会 panic。<br>
    4. 切片容量不能超过最大值：当 slice 容量超过最大值时，会 panic。<br>
    5. 切片的长度和容量不能为负数：长度和容量不能为负数，否则会 panic。<br>
    6. 切片的长度和容量为 0 时，底层数组为 nil。<br></details>

# 3、for range 底层地址发生改变吗？
<details>
  <summary> 查看/隐藏</summary>
  不会，这个遍历是值遍历，每次都新创建当前元素的副本，新建元素副本的地址会变化，但是原来slice不会变化。<br>
</details>

# 4、go defer 多个defer的顺序，defer在什么时机会修改返回值？
<details>
  <summary> 查看/隐藏</summary>
  defer的执行顺序是后进先出，但是在函数返回时，defer的执行效果“先进先出”，所以defer修改返回值时，会在函数返回前修改。<br>
</details>

```go
package main

import (
	"fmt"
)

func example() (result int) {
	defer func() {
		result += 10 // 第一个 defer，修改返回值
		fmt.Println("After first defer, result:", result)
	}()

	defer func() {
		result += 5 // 第二个 defer，修改返回值
		fmt.Println("After second defer, result:", result)
	}()

	result = 0 // 初始返回值
	fmt.Println("Initial result:", result)
	return // 返回时，defer 语句按定义的顺序执行
}

func main() {
	finalResult := example()
	fmt.Println("Final result:", finalResult) // 输出最终的返回值
}

//输出：
Initial result: 0
After second defer, result: 5
After first defer, result: 15
Final result: 15
```

# 5、go 中单引号，双引号，反引号的区别
<details>
  <summary> 查看/隐藏</summary>
  单引号：单引号包裹的字符串，会原样输出，不会转义，适用于一些特殊字符，比如：' '、'\t'、'\n'、'\r'、'\''、'\"'、'\\'等。<br>
  双引号：双引号包裹的字符串，会转义特殊字符，适用于一般字符串。<br>
  反引号：反引号包裹的字符串，会执行系统命令，并将命令的输出作为字符串输出。<br>
</details>

# 6、go 的函数与方法及方法接受者的区别
<details>
  <summary> 查看/隐藏</summary>
  函数：独立，入参出参，实现一些功能，通用函数，没有接受者。<br>
  方法：方法是与某个类型绑定的函数，必须通过该类型的实例调用，或者通过其指针接收者调用。可以修改该类型的对象的状态，提供该类型的功能。<br>
  方法接受者：方法接受者是调用方法的对象，可以是值类型或指针类型。<br>

</details>

# 7、go defer 底层数据结构和一些特性？
<details>
  <summary> 查看/隐藏</summary>
  defer 底层数据结构是一个栈，先进后出，defer 语句在函数返回时，会按定义的顺序执行。<br>
  defer 特性：<br>
  1. 延迟函数调用：defer 语句会将函数调用推迟到函数返回时执行。<br>
  2. 延迟语句块执行：defer 语句可以延迟执行语句块，即使函数调用失败也会执行。<br>
  3. 延迟函数返回值：defer 语句可以延迟函数返回值，并在函数返回时修改。<br>
  4. 延迟panic：defer 语句可以延迟 panic，并在 panic 时恢复正常执行。<br>
  5. 延迟 recover：defer 语句可以延迟 recover，如果当前发生了panic ，<br>
   会被 recover 捕获，手写一下处理函数。如果panic没有发生，recover函数会返回nil。<br>
   比如一个ServeHTTP服务，可以写一个recover的defer函数，来捕获可能发生的panic,不用如下边例子那样写个panic<br>
</details>

recover和panic的应用：第5小用：
```go
package main

import (
	"fmt"
)

func riskyFunction() {
	defer func() {
		if err := recover(); err != nil {
      // 捕获panic，做一些处理，并打印错误信息
      // ...
			fmt.Println("Recovered from panic:", err)
		} else {
			fmt.Println("No panic occurred")
		}
	}()

	fmt.Println("About to panic!")
	panic("Something went wrong!")
}

func main() {
	riskyFunction()
	fmt.Println("After riskyFunction call")
}


输出：
About to panic!
Recovered from panic: Something went wrong!
After riskyFunction call

```

# 8, 9、go 怎么高效的拼接字符串？
<details>
  <summary> 查看/隐藏</summary>
  推荐使用 strings.Builder：在需要拼接多个字符串时，使用 strings.Builder 最为高效，适合性能敏感的场合。<br>
  使用 fmt.Sprintf：对于需要格式化字符串的情况，fmt.Sprintf 很方便，但相对 strings.Builder 可能会稍慢。<br>
  避免使用 + 操作符：在拼接多个字符串时，使用 + 操作符,多次内存分配,会导致性能问题，应该尽量避免。<br>
  针对字符串切片：使用Join函数，也很高效<br>

  
</details>

builder
```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	var builder strings.Builder

	// 拼接字符串
	builder.WriteString("Hello")
	builder.WriteString(", ")
	builder.WriteString("world!")
	
	// 获取最终拼接的字符串
	result := builder.String()

	fmt.Println(result) // 输出: Hello, world!
}



```
fmt.Sprintf
```go
package main

import (
	"fmt"
)

func main() {
	name := "John"
	age := 30

	// 使用 fmt.Sprintf
	result := fmt.Sprintf("Name: %s, Age: %d", name, age)
	fmt.Println(result) // 输出: Name: John, Age: 30
}


```
+号
```go
package main

import (
	"fmt"
)

func main() {
	hello := "Hello"
	world := "world"
	result := hello + ", " + world + "!"
	fmt.Println(result) // 输出: Hello, world!
}


```

# 10、go 两个interface可以比较吗？
<details>
  <summary> 查看/隐藏</summary>
  如果两个接口的类型相同，则可以比较，比较的结果是两个接口的动态值是否相同。如果两个接口的类型不同，则不能比较。<br>
  // 编译错误: invalid operation: a == b (interface and int cannot be compared)<br>
  两个接口都是nil接口的时候可以比较，结果为true。 如果两个接口类型不同，值为nil，也不能比较。<br>
  一般先使用断言来判断类型之后，再比较<br>
  
</details>


# 11、go 中init函数是什么时候执行的？
<details>
  <summary> 查看/隐藏</summary>
  go 中init函数是在编译时，初始化时自动执行的，在main函数之前执行。<br>
	导入包时，程序启动时，会自动执行init函数。<br>
	按依赖关系执行，按所在包的顺序执行，按所在文件的位置顺序执行。<br>
  
</details>

# 12、go语言中怎么比较两个map?
<details>
  <summary> 查看/隐藏</summary>
  因为是键值对，哈希表，无序，所以不能使用==，!= 直接比较。<br>
  可以使用反射来比较，提供运行时检查类型和值的一个包，reflect.DeepEqual(a,b)<br>
  或者自定义一个比较函数，逐个比较<br>

  slice 也不能直接比较，会报错：(slice can only be compared to nil）<br>
</details>

## 12.2 go语言中的map结构基础

```go
哈希表是一个通用的概念。有很多种实现方式。
指一类数据结构： 包括掌管映射的哈希函数、存储数据的底层数组，数组的基本单元：桶。桶可以理解成数组的基本存储单元（存储单个键值对）。如果发生冲突时，桶
需要存储多个键值对，所以桶可以指向一个链表、数组、或者其他数据结构。go 的map中每个桶都包含一个键值对数组和一个引用数组。

go 中 map的数据结构：
hmap更具体地定义了Go中map的实现细节，例如，它支持渐进式扩容、并发安全和特定的存储优化
type hmap struct {
	count     int // 当前hash表的键值对个数
	flags     uint8 // 标志位，用于表示hash表的状态
	B         uint8 // 桶的数量的对数，即2^B个桶
	noverflow uint16 // 溢出桶的数量
	hash0     uint32 // hash种子

	buckets    unsafe.Pointer // 桶的数组，每个桶包含一个键值对数组和一个引用数组
	oldbuckets unsafe.Pointer // 旧桶的数组，用于扩容时的迁移
	nevacuate  uintptr        // 迁移进度，用于扩容时的迁移

	extra *mapextra // 额外的数据结构，用于存储溢出桶的数组
}

```

# 13、go 语言中可以传map的指针吗？
<details>
  <summary> 查看/隐藏</summary>
  不行，地址只是一个地址，map中有更复杂的数据结构来存map结构包括：指针，哈希表，锁来解决冲突，可以使用引用，<br>
  且多个引用指向同一个map，一个更新其他都是可见的。和slice有区别。<br>
</details>

# 14、 go slice、 map 可以边遍历边删除元素吗？
<details>
  <summary> 查看/隐藏</summary>
  slice是通过索引遍历的，删除元素会导致切片的长度和元素顺序发生变化，导致不正确的行为、死循环或者崩溃。<br>
  所以切片删除应当在遍历的时候创建一个新的切片，使用新的切片代替原来的切片。<br>
  map可以，map是读取map键值对的快照，而不是直接操作map,所以删除元素不会影响到遍历<br>
</details>

# 14.2、go 语言中的map是线程安全的吗？
<details>
  <summary> 查看/隐藏</summary>
  map不是线程安全的，在多个goroutine中同时读写map会导致数据竞争，可能导致程序崩溃或者不正确的结果。<br>
  可以使用sync.Map，sync.Map是一个并发安全的map，它提供了一些原子操作，可以在多个goroutine中安全地读写map。<br>
</details>

# 15、 go 中的float可以做map的key吗？
<details>
  <summary> 查看/隐藏</summary>
  不可以，因为float是一个浮点数，它是一个不精确的数值，可能会导致哈希冲突，从而导致map中的值不正确。<br>
  可以使用int，string，bool，array，struct，pointer，interface，channel，func等类型作为map的key。<br>
  c++中可以，但是不建议使用，精度问题，根据需要设置精度范围，或者换成long long int做key。<br>
  
</details>

# 16、go 中的map是有序的吗？怎么实现的？为什么无序？
<details>
  <summary> 查看/隐藏</summary>
  map是一个哈希表，它是通过哈希函数将key映射到一个桶中，所以map中的元素是无序的。<br>
  每个桶中存储一个或多个key-value对，当key的哈希值相同时，会发生哈希冲突，这时会使用链表来解决冲突，<br>
  当链表的长度超过8时，会将链表转换为红黑树，这样可以提高查找的效率。<br>
  因为不需要有序。维护序是为了查找的快，比如有序的数组根据索引直接O(1)找到。<br>
  map结构：实现高效的增、删、改、查、元素。根据键->哈希值->桶 O(1)查找时间复杂度。不用维护key的序。<br>
</details>

# 17、go语言中 map 的扩容机制？
<details>
  <summary> 查看/隐藏</summary>
  Go1.19之后 map的扩容机制是根据当前的负载和预测的负载情况调整桶的数量<br>
  扩容时，会创建一个新的桶，然后将原来的桶中的元素重新哈希到新的桶中。<br>
  扩容是一个渐进式的过程，每次map操作,get,insert,delete时，只会将原来的桶中的一部分元素重新哈希到新的桶中，<br>
  这样可以避免一次性的大量的哈希计算，提高扩容的效率。<br>

</details>

# 18，19、go语言中非接口的任意类型T()都能够调用*T的方法吗？反过来呢？
<details>
  <summary> 查看/隐藏</summary>
  可以，指针类型接收器可以直接调用两种方式，值类型接收器调用指针类型的方法时，会隐式转换成指针。<br>
  
</details>

# 20、go语言中函数返回局部变量的指针是否安全？
<details>
  <summary> 查看/隐藏</summary>
  肯定不安全啊，生命周期。<br>
  1、可以换成全局变量或包级变量。<br>
  2、使用new或者make在堆上分配的变量，<br>
  3、或者使用切片或者map的引用，因为底层也是在堆上。<br>
  
</details>



# 21、go语言中两个nil可能不相等吗？
<details>
  <summary> 查看/隐藏</summary>
  nil有类型，类型不同即使nil的值相同也不行。<br>
  接口的动态类型不同，都是nil，也不相等。<br>
  
</details>


# 22、go语言中map赋值过程怎么样？
<details>
  <summary> 查看/隐藏</summary>
  使用make创建map,分配内存，返回指针，<br>
</details>

# 23、go语言中go语言中如何实现两种get操作？
<details>
  <summary> 查看/隐藏</summary>
  方式1：通过键或者索引直接访问，<br>
  方式2：自定义一个函数来封装，value, exists := m[key]<br>
  
</details>

# 24、go语言中切片作为函数参数，是值传递还是引用传递？
<details>
  <summary> 查看/隐藏</summary>
  所有函数传参都是值传递的。如果函数内的切片没有扩容，因为切片是引用类型，所以会修改同一份底层数据。<br>
  如果使用append追加元素，扩容了，则不是原来的数组了。【https://www.cnblogs.com/wzj4858/p/18256857】<br>
  
</details>

# 25、go语言中哪些不能作为map的key?
<details>
  <summary> 查看/隐藏</summary>
  确定的数据可以作为key,如基本数据类型：int,string,精度ok的float,<br>
  切片引用类型，其中的数据可以变化，所以不能。map也会变，函数不能被哈希所以不能，结构体中如果有不能作为key的字段，这个结构体就也不行。<br>
  如果结构体中所有字段都可以，那这个结构体就能作为key，<br>
</details>

# 26、go语言中nil map和空 map有啥不同？
<details>
  <summary> 查看/隐藏</summary>
  nil map是没有初始化的，所以也没有分配内存。不能进行添加等操作，会panic.<br>
  而空 map是初始化过的，初始化之前分配了内存。可以进行添加，删除操作。<br>
</details>

# 27、go语言中删除一个key,它的内存会释放吗？
<details>
  <summary> 查看/隐藏</summary>
  delete(myMap, "grape"),在逻辑上删除了key,和它对应的值，内存释放等待垃圾回收。<br>
</details>

# 28、go语言中map使用的点，并发是否安全？
<details>
  <summary> 查看/隐藏</summary>
  必须初始化，可以通过键来添加和修改，读取如果不存在会获取到零值，可以用delete(mp, "key"),遍历使用range，<br>
  并发环境中不是线程安全的，可以使用读写锁。sync.RWMutex<br>
  
</details>


```
var mu sync.RWMutex
myMap := make(map[string]int)

// 写操作
func writeToMap(key string, value int) {
    mu.Lock()
    defer mu.Unlock()
    myMap[key] = value
}

// 读操作
func readFromMap(key string) int {
    mu.RLock()
    defer mu.RUnlock()
    return myMap[key]
}

```

# 29、go语言中调用函数传入结构体时，应该传值还是传指针？
<details>
  <summary> 查看/隐藏</summary>
  如果结构体比较小，且不想修改原结构体，传值比较好，<br>
  如果结构体比较大，或者想修改原结构体，传指针比较好。<br>

</details>

# 30、go语言中解析tag怎么实现的？
<details>
  <summary> 查看/隐藏</summary>
   使用reflect包来解析结构体标签，使用reflect.TypeOf()获取结构体类型，然后遍历结构体的字段，获取字段的标签。<br>

</details>


```
package main

import (
	"fmt"
	"reflect"
)

// 带有标签的示例结构体
type MyStruct struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func main() {
	// 创建MyStruct的实例
	s := MyStruct{Name: "独孤剑圣", Age: 42}

	// 获取结构体的类型
	t := reflect.TypeOf(s)
	fmt.Println(t)
	fmt.Printf("\nt type is %T\n", t)

	// 遍历结构体的字段
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		// 获取字段的标签
		tag := field.Tag.Get("json")
		fmt.Printf("字段: %s, 标签: %s\n", field.Name, tag)
	}
}

```

# 31、go语言中 简述go中的rune类型
<details>
  <summary> 查看/隐藏</summary>
  是int32类型的别名，用来表示字符，int32用来表示数字。<br>
  byte 是uint8的别名，用来表示字节，uint8用来表示数字。<br>
  rune 用来处理长度大于1字节，小于等于4字节的字符，比如汉字占3字节。<br>
  rune 用来统计带汉字字符串的字符长度。len()函数返回的是字节数。<br>
  （如 var st = "Go语言编程" len(st)=14，是 2 + 3 * 4， 而len([]rune(st）） = 6)<br>
  rune 用来截取字符串（如带汉字的字符串， 大于128的字符），<br>

 https://www.cnblogs.com/cheyunhua/p/16007219.html
</details>

# 32、go语言中sync.Map的用法？
<details>
  <summary> 查看/隐藏</summary>
  并发安全，多线程环境中高效工作，不用手动加锁。适合读多写少的场景。<br>
   使用：m.Store(),m.Load(),m.Delete(),m.Range()<br>
   如果是写多读少的场景，会变慢，性能不如自己使用sync.Mutex手动加锁（自己针对自己的业务场景，更细粒度的加锁）。原因：<br>
   内部实现：就是为了读多写少这种场景封装的map。优化点：1. “分段锁” 读写分离，读时不加锁，写时才加锁。<br>

</details>


```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var m sync.Map

	// 存储值
	m.Store("key1", "value1")
	m.Store("key2", "value2")

	// 加载值
	value, ok := m.Load("key1")
	if ok {
		fmt.Println("Key1 Value:", value)
	}

	// 遍历
	m.Range(func(key, value interface{}) bool {
		fmt.Printf("Key: %v, Value: %v\n", key, value)
		return true // 继续遍历
	})

	// 删除值
	m.Delete("key2")

	// 加载已删除的值
	_, ok = m.Load("key2")
	if !ok {
		fmt.Println("Key2 has been deleted")
	}
}

```


# 33、go语言中struct能不能比较？
<details>
  <summary> 查看/隐藏</summary>
  取决于里边的项，如果所有的项都可以比较那就可以比较，<br>
  如果有不能比较的项，那就是不能比较。（切片，map,函数等，引用类型都不能比较）<br>

</details>

# 34、go语言中值接收者和指针接收者有啥区别？
<details>
  <summary> 查看/隐藏</summary>
  值接收者：通过值的复制来接收接收者对象。会创建接收者对象的副本。对接收者的任何修改都不会影响原对象。使用场景：不修改原接收者，只读其中的值，且结构体比较小。<br>
  指针接收者：通过指针来接收接收者对象。传递的是接收者的地址。会修改原对象。使用场景：需要修改接收者的值，结构体较大，避免拷贝。<br>

</details>


# 35、go语言中简述go的数据类型
<details>
  <summary> 查看/隐藏</summary>
  bool,int,float32,64,sting,map,rune,byte,<br>
  slice,map,chan,struct,interface,func,pointer<br>

</details>


# 36、go语言中函数返回局部变量的指针是否安全？
<details>
  <summary> 查看/隐藏</summary>
  在栈上，会导致未定义的行为，所以应该建在堆上，<br>

</details>


# 37、go语言中解释array和slice的区别
<details>
  <summary> 查看/隐藏</summary>
  array是固定大小的，slice是动态大小的，可以追加元素，可以切片。<br>
  array是值类型，slice是引用类型。<br>
</details>


# 38、go语言中什么是负载因子？
<details>
  <summary> 查看/隐藏</summary>
  负载因子 = len(map) / cap(map)<br>
  当负载因子比较低时，表明内存利用率低，哈希碰撞概率也低。<br>
  当负载因子比较高时，表明内存利用率高，哈希碰撞概率也高，当高于某个界线时，会扩容（申请新一块内存，重新哈希过去），<br>

</details>


# 39、go语言中 map和sync.Map谁的性能更好？
<details>
  <summary> 查看/隐藏</summary>
  需要分类讨论，自带的map没有锁，单线程时很快。sync.Map封装了下，适合读多写少的场景。<br>
  封装了写时加锁。读时无锁。所以高并发场景下，sync.Map更适合。<br>
  高并发写多时，自带的map自己加锁性能更好。<br>
  
</details>



# 40、go语言中chan底层数据结构和主要使用场景？
<details>
  <summary> 查看/隐藏</summary>
  实现：使用一个go routine,和同步机制，锁或者条件变量，+buffer（使用数组或者切片）<br>
  特点：先进先出，同步，没缓冲区的channel,当这个chan的数据没被消费的时候会阻塞，直到有数据被消费。<br>
  使用场景：<br>
  1. 用于协程间通信，比如生产者消费者模型。共享数据<br>
  2. 实现goroutine同步，一个协程等一个信号from 另外一个goroutine<br>
  3. 生产者消费者场景<br>
  4. 减少对共享资源的直接访问，通过channel传数据，减少数据竞争。<br>
  5. 有阻塞状态，不会死锁。（数据流动）<br>

  读写锁，写锁。<br>
  读多写少使用读写锁。写锁是独占锁。<br>

  使用锁可以<br>
  互斥锁适用读少写多的场景<br>

  go语言的常量可以根据上下文确定。<br>
</details>

```golang

package main

import (
	"fmt"
	"sync"
	"time"
)

var (
	mutex          sync.Mutex
	condition      = sync.NewCond(&mutex)
	resourceReady  = false
)

func worker(id int) {
	mutex.Lock()
	defer mutex.Unlock()

	// Wait until the resource is ready
	for !resourceReady {
		fmt.Printf("Worker %d is waiting for resource...\n", id)
		condition.Wait()
	}

	// Resource is ready, perform work
	fmt.Printf("Worker %d is working with the resource!\n", id)
}

func main() {
	const numWorkers = 3

	// Start worker goroutines
	for i := 1; i <= numWorkers; i++ {
		go worker(i)
	}

	time.Sleep(1 * time.Second) // Simulate some delay before resource is ready

	// Prepare the resource and notify all waiting workers
	mutex.Lock()
	resourceReady = true
	fmt.Println("Resource is ready, notifying workers...")
	condition.Broadcast() // Notify all waiting goroutines
	mutex.Unlock()

	// Wait for some time to let workers finish
	time.Sleep(2 * time.Second)
	fmt.Println("All workers done.")
}
```

# 41、go语言中多返回值怎么实现的?
<details>
  <summary> 查看/隐藏</summary>
  写返回值的地方<br>
  在go的类型系统中 对函数类型的定义 比较灵活，在底层也是对返回值做了封装，类似封装结构体<br>
</details>


# 42、go语言中 init函数的特征？
<details>
  <summary> 查看/隐藏</summary>
  启动时 自动调用<br>
没有参数也返回值<br>
不能被其他函数调用<br>
按照包引用顺序执行，如果同一个包内多个文件都有init函数，则按照文件名的字母顺序执行<br>
适合做包级别的准备工作<br>
  
</details>

# 43、go语言中Pointer和unsafe.Pointer区别？
<details>
  <summary> 查看/隐藏</summary>
  Pointer 是go语言中的常规指针，指向某个变量的地址，类型安全，unsafe.Pointer 跳过类型检查，灵活性更高，能够进行低级别的内存操作。<br>

  
</details>

# 44、go语言中interface和struct的区别？
<details>
  <summary> 查看/隐藏</summary>
  interface 是一种抽象类型，可以定义方法集，struct 是一种具体类型，可以包含字段。<br>

  
</details>

# 45、go语言中空结构体struct{}的用途？
<details>
  <summary> 查看/隐藏</summary>
  特点：不占用内存，大小为0<br>
  用途：用于占位，在数据结构中表示某种状态或存在性，比如使用map实现set结构。<br>
       作函数的返回值。和无返回值一样。比无返回值的优点是 可以 a.符合某些接口需要；b.API体验更好；c.未来扩展，需要带返回值时，可以不用修改接口。<br>

  
</details>


```golang
type Set struct {
	m map[interface{}]struct{}
}
```

# 46、两个变量值的四种交换方式？
<details>
  <summary> 查看/隐藏</summary>
  
  多重赋值：
a, b = b, a

临时变量：
c := a
a = b
b = c

算数运算：
a = a + b
b = a - b
a = a - b

位运算：(只适合整数)
a = a ^ b
b = a ^ b
a = a ^ b
</details>

# 47、go语言中 string类型的值可以修改吗？
<details>
  <summary> 查看/隐藏</summary>
  是只读的字节切片。拼接、切割、替换 会新产生一个字符串。<br>
不可变的对象可以提高内存效率(减少管理，共享和重用，简化缓存，更少的垃圾回收性能)，且在多线程中是安全的。<br>

  
</details>

```go
s := "hello"
s[0] = 'x'  // 编译错误：cannot assign to s[0]
```

# 48、go语言中switch中如何强制执行下一个case？
<details>
  <summary> 查看/隐藏</summary>
  使用fallthrough关键字。<br>
  
</details>

# 49、go语言中如何关闭http的响应体？
<details>
  <summary> 查看/隐藏</summary>
  使用defer resp.Body.Close()。<br>
  
</details>

# 50、go语言中 如何实现一个单例模式？
<details>
  <summary> 查看/隐藏</summary>
  使用sync包中的Once结构体。<br>
  
</details>

```go
package main

import (
	"fmt"
	"sync"
)

// Singleton struct
type Singleton struct {
}

var instance *Singleton
var once sync.Once

// GetInstance returns the singleton instance
func GetInstance() *Singleton {
	once.Do(func() {
		instance = &Singleton{}
	})
	return instance
}

func main() {
	s1 := GetInstance()
	s2 := GetInstance()

	fmt.Println(s1 == s2) // This will print: true
}


```

# 51、go语言中 如何实现一个线程安全的计数器？
<details>
  <summary> 查看/隐藏</summary>
  使用sync包中的Mutex结构体。<br>
  
</details>

# 52、go语言中 49:解析json时，默认把数值当成什么类型？50,如何从panic中恢复？51、如何初始化带嵌套结构的结构体？
<details>
  <summary> 查看/隐藏</summary>
  49：数值 默认当成float64
  50：写一个defer函数，在recover中处理panic，并打印相关信息。<br>
      如果panic没有触发，则recover函数会返回nil 见第7问的答案。<br>
  51：创建一个内层结构体的实例传给外层结构体的域。<br>

```go
package main
import "fmt"
type Address struct {
  Stress string
  City string
}

type Person struct{
  Name string
  Age int
  Address Address
}

func main() {
  person := Person{
    Name : "John",
    Age : 18,
    Address:Address{
      Stress : "123 Main St",
      City : "New York",
    },
  }
  fmt.Println(person)
}

 ``` 
  
</details>

# 53、go语言中 简述Printf,Sprintf,Fprintf的区别？和用法
<details>
  <summary> 查看/隐藏</summary>
  都是用来格式化字符串的函数。
  Printf(format string, args interface{}) (n int, err erros)向标准输出（控制台）打印格式化的字符串，
  返回写入的字节数和遇到的任何错误。
  Sprintf(format string, args interface{}) (string ), 不打印，返回格式化后的字符串，通常赋值给变量。
  Fprintf(w io.Writer, format string, args interface{}) (n int, err errors) 类似Sprintf，但将格式化后的字符串写入io.Writer。[文件、网络连接、缓冲区]而不是直接输出到标准输出。
  
  
</details>

# 54、go语言中 如何Array的值作为函数的参数？
<details>
  <summary> 查看/隐藏</summary>
  函数参数都是值传递的，所以如果只是传数组，在函数内部对数组做的改变，不会改变原来的数组
  不过可以穿数组的指针，可以用来改变数组的值，
  或者使用切片，切片是数组的引用，也可以达到修改数组的效果。
  
  
</details>

# 55、go语言中 55.1、简述类型断言？55.2、局部变量和全局变量的缺省值是什么？
<details>
  <summary> 查看/隐藏</summary>
  1、用于运行时判断接口的具体类型，判断是否实现了某个接口，以及获取接口的具体值。<br>
  2、都不会报错，都会赋值默认值，0，和0.0，false，""，nil<br>
  
</details>

```go
package main

import (
    "fmt"
)

type Animal interface {
    Speak() string
}

type Dog struct{}
func (d Dog) Speak() string {
    return "Woof!"
}

type Cat struct{}
func (c Cat) Speak() string {
    return "Meow!"
}

func printAnimalSound(animal Animal) {
    // 类型断言
    if dog, ok := animal.(Dog); ok {
        fmt.Println("Dog says:", dog.Speak())
    } else if cat, ok := animal.(Cat); ok {
        fmt.Println("Cat says:", cat.Speak())
    } else {
        fmt.Println("Unknown animal")
    }
}

func main() {
    var a Animal

    a = Dog{}
    printAnimalSound(a) // 输出: Dog says: Woof!

    a = Cat{}
    printAnimalSound(a) // 输出: Cat says: Meow!
}


```
# 56、go语言中 静态类型声明？动态类型声明？
<details>
  <summary> 查看/隐藏</summary>
  静态声明：使用var声明[可以声明变量组]，使用const声明，函数内部 使用短声明，意味着变量在编译时已经确定好了
  动态声明：使用interface实现，任何实现了接口的类型，都可以当成接口的实例使用
</details>

# 57、go语言中 简述可变参数的用法？
<details>
  <summary> 查看/隐藏</summary>
  相同类型，数量不固定，使用...表示，可作为函数形参，需要放最后。
  切片作为实参传到函数时，使用切片名 + ...表示。
</details>

```go
func Sum(values ...int) int {
    total := 0
    for _, v := range values {
        total += v
    }
    return total
}


func main() {

  result2 := Sum(4, 5, 6, 7, 8)
  fmt.Println(result2) // 输出 30


  numbers := []int{1, 2, 3, 4, 5}
  result := Sum(numbers...) // 使用切片传递参数
  fmt.Println(result) // 输出 15
}

```

# 58、go语言中 解释空接口、nil interface 和nil 值 的区别？
<details>
  <summary> 查看/隐藏</summary>
  nil 值，表示具体类型[切片，channel，map，指针，函数]的“空”值 <br>
 <br>
  接口定义一组方法，任何实现了这些方法的具体类型，均可认为是该接口的实例。 <br>
  <br>
  空接口： <br>
  空接口的类型是interface{}，值是nil。任何类型（除了结构体，也可以是各种非空接口）都可以赋值给空接口。 <br>
  修改它的动态类型和值，还可以继续赋值成其他类型的值。动态类型继续变化，但还是叫空接口类型。 <br>
 <br>
  nil接口： <br>
  nil接口是一个泛指的术语。值为nil的任何类型的接口，统称为nil接口。所以空接口可以认为是nil接口的一种。 <br>
  nil interface泛指值为nil的任意接口。 <br>
</details>


```go
var empty interface{} // 空接口，值为 nil
empty = 42           // 赋值为整型，动态类型为 int
empty = "Hello"      // 赋值为字符串，动态类型为 string

var j interface{} = (*MyType)(nil) 

var i interface{} // 声明一个interface类型的变量i，既是nil接口又是空接口
fmt.Println(i == nil) // 输出 true，i是一个nil接口
```


# 59、go语言中 导入包时使用_, /, . 分别表示啥意思？
<details>
  <summary> 查看/隐藏</summary>
  _ 表示只导入包中的初始化函数，当前包并不直接引用它，不使用包中其他任何标识符。
  / 用于分割不同级别的包，
  . 表示直接导入包中所有的标识符到当前包，不用包名的前缀。
  
</details>


# 60、go语言中 interface{}是否支持java中的多继承？
<details>
  <summary> 查看/隐藏</summary>
  通过接口和组合的方式可以实现类似功能。
  一个类型可以实现多个接口，
  通过组合其他结构体来复用代码，把其他结构体作为新结构体的子域，从而获得他们的字段和方法。
</details>

# 61、go语言中 sync包是什么？
<details>
  <summary> 查看/隐藏</summary>
  go语言的标准库之一。提供基本的同步原语，包括互斥锁、读写锁、WaitGroup、条件变量、Once等。有效管理多个goroutine之间的同步和通信。
  sync.Mutex: 互斥锁，Lock,和Unlock方法
  sync.RWMutex: 读写锁，RLock,和RUnlock方法,适用于读远远大于写的场景
  sync.WaitGroup: 等待组，用于等待一组goroutine完成任务
  sync.Cond: 条件变量，用于等待条件满足后通知
  sync.Once:确保某个操作只执行一次，单例模式，或初始化场景，通过Do方法指定要执行的操作。
  sync.Pool: 内存池，用于缓存和重用对象，减少内存分配和GC压力。

</details>

# 63、go语言中 简述scheduler的工作原理？
<details>
  <summary> 查看/隐藏</summary>
  go语言的调度器，是并发模型的核心。goroutine轻量级线程，由go运行时管理。
  工作线程P,调度器使用工作线程P,来实际执行goroutine,每个P有自己的可运行队列，用于存放待执行的goroutine。
  【工作线程P：是一个调度上下文，负责调度和管理 goroutine 的执行】

  操作系统线程M,调度器在M上调度P和goroutine,每个M运行一个P。M和P是多对多的。
  【M 是实际的操作系统线程，负责执行 goroutine】

  cpu是center process unit,中央处理器，硬件。一个cpu可以有多个核core
  操作系统线程M,是操作系统调度的最小单元，负责执行goroutine。软件角度。
  m个M,n个core,m可以大于，小于，等于n。一般是m>n

  goroutine(G),G是goroutine的实例，当一个goroutine被创建时，分配一个G.
  调度过程：
   当1个goroutine被创建时，会被go的运行时 放入一个当前正在运行的P的可运行队列上。
   当1个P的可运行队列为空时，P会被阻塞，等待其他goroutine加入可运行队列。
   每个P维护两个队列：可运行队列，阻塞队列。当P的执行的goutine执行完毕后（1、时间片到了，会暂停它，把它放到可运行队列； 2、
   等待资源，从运行状态移到阻塞队列； 3、任务结束，清理资源（堆栈空间和其他资源），从M中移除，通知P,喊下一个）。

   工作窃取：Go 调度器会定期监测每个 P 的可运行队列的状态，如果发现某个P比较空闲时，会从忙的 P 的可运行队列中窃取一些 goroutine。

  问：为什么不整体维护一个阻塞队列？而每个P都维护两个队列？
  性能和效率：减少锁竞争。共享资源需要加锁。
  减少上下文切换：减少线程切换，提高执行效率。
  局部性原则，
  响应速度更快，
  减少复杂性。

  问轻量级体现在哪？
  1.内存占用更小：栈空间更小：2kB，正常的线程是1MB或更大
  2.创建和销毁成本：goroutine由go的运行时管理，因此在需要时可以迅速创建数千甚至数万个 Goroutine，而传统线程的创建则可能会导致显著的系统开销。
  3.调度：由go的调度器完成，调度器可以在许多 goroutine 之间进行切换，且这种切换的开销相对较低，因为它只需要保存和恢复少量的上下文信息。相比之下，线程切换通常需要更多的上下文保存、恢复以及涉及到用户态和内核态之间的切换。
  4.并发管理：Goroutine 是语言级的并发工具，Go 提供了简单易用的语法和结构来处理并发。这使得程序员可以在不关注底层线程管理的情况下，编写出具有高度并发能力的程序。
  5.资源利用：Go 的运行时系统可以根据可用的 CPU 核心和当前的负载动态地分配 goroutine 到操作系统线程。这种灵活性使得 Goroutine 能够有效地利用系统资源

  
</details>

# 64、go语言中 简述全局运行队列中获取groutine
<details>
  <summary> 查看/隐藏</summary>
  当一个新的goroutine被创建后，会被放到全局可运行队列，或者某个工作线程P的局部可运行队列中，等待被调度。
  当某个工作线程P的可运行队列为空，就会去全局可运行获取新的goroutine。
</details>

# 65、go语言中 简述如何从工作线程本地运行队列获取groutine？
<details>
  <summary>查看/隐藏</summary>
  工作线程P的局部可运行队列，是工作线程P自己管理的队列，当P的可运行队列为空时，会从全局可运行队列获取新的goroutine。
</details>

# 66、如下go语言中panic语句会执行吗？panic是啥？怎么处理？
<details>
  <summary> 查看/隐藏</summary>
  select语法，和chan一起使用，等待多个chan事件，只要有一个case可以执行，就会退出select。
  如果有多个chan ready,会随机选择（多协程时候），因为当前是单协程的，会按照顺序执行，
  所以在执行到intChan的时候，就会退出select.
  <br>
  panic：是一个内置函数，接收一个任意类型的参数。作为错误信息上报给运行时。
  之后当前goroutine会按栈的顺序逐层执行defer函数，
  <br>
  如果defer函数中有recover函数，panic会被捕获，被处理，然后继续执行后续的代码。
</details>

```go
func Test5(t *testing.T) {
	runtime.GOMAXPROCS(1)
	intChan := make(chan int, 1)
	stringChan := make(chan string, 1)
	intChan <- 1
	stringChan <- "hello"
	select {
	case value := <-intChan:
		fmt.Println(value)
	case value := <-stringChan:
		panic(value)
	}
}

```

# 67、go语言中 包是什么？
<details>
  <summary> 查看/隐藏</summary>
  一组相关源代码文件的集合。是go语言基本组织单位。包含包声明、导入声明、常量、类型、变量、函数、测试代码等。
  导入：import，可以起别名。
  包名：一般为小写，多个单词用下划线连接。一般与目录名一致。
  标准库（net/http, fmt, os）与第三方库，
  可见性：首字母大小写。
  编译和链接：go的编译器根据包的依赖关系进行编译和链接。通过包的机制实现代码复用和隔离。

  
</details>


# 68、go语言中 
<details>
  <summary> 查看/隐藏</summary>

  
</details>

# 61、go语言中 
<details>
  <summary> 查看/隐藏</summary>

  
</details>

# 61、go语言中 
<details>
  <summary> 查看/隐藏</summary>

  
</details>

# 61、go语言中 
<details>
  <summary> 查看/隐藏</summary>

  
</details>

# 61、go语言中 
<details>
  <summary> 查看/隐藏</summary>

  
</details>

# 61、go语言中 
<details>
  <summary> 查看/隐藏</summary>

  
</details>

# 61、go语言中 
<details>
  <summary> 查看/隐藏</summary>

  
</details>

# 61、go语言中 
<details>
  <summary> 查看/隐藏</summary>

  
</details>

# 61、go语言中 
<details>
  <summary> 查看/隐藏</summary>

  
</details>

# 61、go语言中 
<details>
  <summary> 查看/隐藏</summary>

  
</details>

# 61、go语言中 
<details>
  <summary> 查看/隐藏</summary>

  
</details>

# 61、go语言中 
<details>
  <summary> 查看/隐藏</summary>

  
</details>

# 61、go语言中 
<details>
  <summary> 查看/隐藏</summary>

  
</details>